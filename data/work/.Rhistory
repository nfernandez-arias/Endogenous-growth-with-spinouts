# and can then be dropped.
inventors[, patent := as.numeric(as.character(patent))]
#inventors$patent <- as.numeric(as.character(inventors$patent))
inventors[, inventorState := as.character(inventorState)]
#inventors$inventorState <- as.character(inventors$inventorState)
inventors <- inventors[!is.na(patent)]
#inventors <- inventors %>% dplyr::filter(!is.na(patent))
# Select only relevant variables: patent number and inventor state
inventors <- inventors %>% dplyr::select(patent,inventorState)
##### Merge datasets using data.table
setkey(inventors,patent)
setkey(patents,patent)
inventorsPatents <- merge(patents,inventors)
##### Clean up: remove inventors, patents data.tables
rm(list = c("inventors","patents"))
######################################################################
######################################################################
## Construction of geographic distribution of R&D for each gvkey-year
#
## Algorithm:
#
# For inventorsPatents dataset, Create new variable, inventorCount, that
# counts number of inventors for each patent (i.e. count # of observations per patent)
# Then invert - this is now the weight assigned to each patent-city observation.
#
# This only gives me the ability to assign a state to gvkey-year observations
# that match the patent database, i.e. where the company applied for
# a patent.
#
# In order to use all, need to next import dynass and compustat,
# merge with inventorsPatentsWeights, and do the following:
#
# (1) Assign a weight of 1 to gvkey-year observations which do not have a patent
# (2) Assign the gvkey-year state to inventorState for those observations
# (i.e. treat all R&D as occuring in the main state of the company when the company
# does not apply for any patents in that year - the natural approximation)
#
######################################################################
######################################################################
### Compute weights - easy with data.table
#inventorsPatentsWeights <- inventorsPatents[ , weight := .N, by]
#inventorsPatentsWeights$weight <- 1/inventorsPatentsWeights$weight
# clean up
#rm(list=c("inventorsPatents"))
### Load in dynass, compustat and merge
## Load dynass
dynass <- read.dta13('Data/dynass_reshaped.dta')
# Clean
dynass$gvkey <- as.integer(dynass$gvkey)
dynass <- dynass %>% select(gvkey,pdpass,year)
## Merge inventorsPatentsWeights and dynass
# Prepare for merge
dynass <- data.table(dynass)
setkey(dynass,pdpass,year)
setkey(inventorsPatents,pdpass,year)
# Merge
inventorsPatentsDynass <- merge(inventorsPatents,dynass)
## Clean up: remove inventorsAndPatents and dynass
rm(list = c("inventorsPatents","dynass"))
#### Merge patentsAssigneesDynass with compustat's XRD data
## Load compustat dataset and clean
compustat <- fread('Data/compustat.csv')
compustat <- compustat %>% select(gvkey,fyear,xrd,state)
compustat$year <- compustat$fyear
compustat$gvkey <- as.integer(compustat$gvkey)
## Merge and clean
# Convert compustat to data.table and set keys
setkey(compustat,gvkey,year)
setkey(inventorsPatentsDynass,gvkey,year)
inventorsPatentsCompustat <- merge(inventorsPatentsDynass,compustat,by = c("gvkey","year"),all.y = TRUE)
# For diagnostics, save here so I don't have to redo above
inventorsPatentsCompustat <- inventorsPatentsCompustat %>% select(-pdpass,-fyear)
#fwrite(inventorsPatentsCompustat, file = "Data/inventorsPatentsCompustat.csv")
#inventorsPatentsCompustat <- fread("Data/inventorsPatentsCompustat.csv", na.strings = c("",NA))
# Count number of patents per gvkey-year to modify weight so we can simply sum over gvkey-year entries later
inventorsPatentsCompustat[, numInventorsInGvkeyYearPatent := .N, by = c("gvkey","year","patent")]
inventorsPatentsCompustat[, numPatentsInGvkeyYear := uniqueN(patent), by = c("gvkey","year")]
inventorsPatentsCompustatWeights <- inventorsPatentsCompustat[, weight := 1 / (numInventorsInGvkeyYearPatent * numPatentsInGvkeyYear)]
rm(list = c("inventorsPatentsCompustat","compustat"))
# Make tibble - necessary for spread()
inventorsPatentsCompustatWeights[is.na(inventorState),inventorState := state]
inventorsPatentsCompustatWeights[,state := NULL]
inventorsPatentsCompustatWeights <- inventorsPatentsCompustatWeights %>% dplyr::rename(state = inventorState)
# Compute sum of weights by gvkey-year-inventorState
gvkeyYearStateWeights <- inventorsPatentsCompustatWeights[, lapply(.SD,sum), by = c("gvkey","year","state"), .SDcols = "weight"]
gvkeyYearXrd <- unique(inventorsPatentsCompustatWeights, by=c("gvkey","year"))[,c("gvkey","year","xrd")]
# Compute moving averages
# First sort by gvkey-year
setkey(gvkeyYearStateWeights,gvkey,year)
# Reshape to wide
gvkeyYearStateWeights[, ID := .I]
gvkeyYearStateWeights <- gvkeyYearStateWeights %>% spread(state,weight)
?roll_mean
# Now can compute rolling averages of weights for each state easily
new_weights <- gvkeyYearStateWeights[, lapply(.SD,roll_mean,n = 3L), .SDcols = 3:68]
# Now can compute rolling averages of weights for each state easily
new_weights <- gvkeyYearStateWeights[, lapply(.SD,roll_mean,n = 3L, fill = 0), .SDcols = 3:68]
# Now can compute rolling averages of weights for each state easily
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RccpRoll::roll_mean,n = 3L, fill = 0), .SDcols = 3:68]
library(RcppRoll)
# Now can compute rolling averages of weights for each state easily
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RccpRoll::roll_mean,n = 3L, fill = 0), .SDcols = 3:68]
# Now can compute rolling averages of weights for each state easily
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L, fill = 0), .SDcols = 3:68]
# Now can compute rolling averages of weights for each state easily
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L), .SDcols = 3:68]
# Now can compute rolling averages of weights for each state easily
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = numeric(0)), .SDcols = 3:68]
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[is.na(.SD),.SD := 0]
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[, names(DT) := lapply(.SD, function(x) {x[is.na(x)] <- "0"; x})]
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[, names(gvkeyYearStateWeights) := lapply(.SD, function(x) {x[is.na(x)] <- "0"; x})]
# Compute sum of weights by gvkey-year-inventorState
gvkeyYearStateWeights <- inventorsPatentsCompustatWeights[, lapply(.SD,sum), by = c("gvkey","year","state"), .SDcols = "weight"]
gvkeyYearXrd <- unique(inventorsPatentsCompustatWeights, by=c("gvkey","year"))[,c("gvkey","year","xrd")]
# Compute moving averages
# First sort by gvkey-year
setkey(gvkeyYearStateWeights,gvkey,year)
# Reshape to wide
gvkeyYearStateWeights[, ID := .I]
gvkeyYearStateWeights <- gvkeyYearStateWeights %>% spread(state,weight)
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[, names(gvkeyYearStateWeights) := lapply(.SD, function(x) {x[is.na(x)] <- "0"; x})]
?lapply
rm(list=ls())
set.seed(10238)
# A and B are the "id" variables within which the
#   "data" variables C and D vary meaningfully
DT = data.table(A = rep(1:3, each = 5), B = rep(1:5, 3),
C = sample(15), D = sample(15))
View(DT)
View(DT)
DT
DT[, lapply(.SD,sum), by = A]
DT[, names(DT) := lapply(.SD,sum),by = A]
DT[, 2:4 := lapply(.SD,sum),by = A]
View(DT)
set.seed(10238)
# A and B are the "id" variables within which the
#   "data" variables C and D vary meaningfully
DT = data.table(A = rep(1:3, each = 5), B = rep(1:5, 3),
C = sample(15), D = sample(15))
DT[, names(DT) := lapply(.SD,sum),by = A]
View(DT)
set.seed(10238)
# A and B are the "id" variables within which the
#   "data" variables C and D vary meaningfully
DT = data.table(A = rep(1:3, each = 5), B = rep(1:5, 3),
C = sample(15), D = sample(15))
DT[, names(DT) := lapply(.SD,sum),by = A]
View(DT)
rm(list=ls())
rm(list = setdiff(ls(), lsf.str()))
setwd("/home/nico/nfernand@princeton.edu/PhD - Big boy/Research/Endogenous growth with worker flows and noncompetes/data/work")
## Load libraries and auxiliary functions
library(profvis)
library(readstata13)
library(dplyr)
library(plyr)
library(tidyr)
library(data.table)
library(plm)
source('Code/Functions/stata_merge.R')
##### Load in and clean patents dataset
patents <- fread('Data/patents.csv')
patents <- patents %>% dplyr::rename(year = appyear, assigneeState = state, assigneeCountry = country)
patents <- patents %>% dplyr::select(patent,pdpass,year)
##### Load in and clean inventors datasets
# Use data.table::fread -- it is an order of magntiude faster than read.csv
inventors <- fread(file = "Raw/inventor.csv")
# Rename variables
inventors <- inventors %>% dplyr::rename(patent = Patent, inventorCountry = Country, inventorZipCode = Zipcode, inventorState = State, inventorCity = City)
# Convert patent # to numeric. Non-utility patents have non-numeric characters, so these become NAs
# and can then be dropped.
inventors[, patent := as.numeric(as.character(patent))]
#inventors$patent <- as.numeric(as.character(inventors$patent))
inventors[, inventorState := as.character(inventorState)]
#inventors$inventorState <- as.character(inventors$inventorState)
inventors <- inventors[!is.na(patent)]
#inventors <- inventors %>% dplyr::filter(!is.na(patent))
# Select only relevant variables: patent number and inventor state
inventors <- inventors %>% dplyr::select(patent,inventorState)
##### Merge datasets using data.table
setkey(inventors,patent)
setkey(patents,patent)
inventorsPatents <- merge(patents,inventors)
##### Clean up: remove inventors, patents data.tables
rm(list = c("inventors","patents"))
######################################################################
######################################################################
## Construction of geographic distribution of R&D for each gvkey-year
#
## Algorithm:
#
# For inventorsPatents dataset, Create new variable, inventorCount, that
# counts number of inventors for each patent (i.e. count # of observations per patent)
# Then invert - this is now the weight assigned to each patent-city observation.
#
# This only gives me the ability to assign a state to gvkey-year observations
# that match the patent database, i.e. where the company applied for
# a patent.
#
# In order to use all, need to next import dynass and compustat,
# merge with inventorsPatentsWeights, and do the following:
#
# (1) Assign a weight of 1 to gvkey-year observations which do not have a patent
# (2) Assign the gvkey-year state to inventorState for those observations
# (i.e. treat all R&D as occuring in the main state of the company when the company
# does not apply for any patents in that year - the natural approximation)
#
######################################################################
######################################################################
### Compute weights - easy with data.table
#inventorsPatentsWeights <- inventorsPatents[ , weight := .N, by]
#inventorsPatentsWeights$weight <- 1/inventorsPatentsWeights$weight
# clean up
#rm(list=c("inventorsPatents"))
### Load in dynass, compustat and merge
## Load dynass
dynass <- read.dta13('Data/dynass_reshaped.dta')
# Clean
dynass$gvkey <- as.integer(dynass$gvkey)
dynass <- dynass %>% select(gvkey,pdpass,year)
## Merge inventorsPatentsWeights and dynass
# Prepare for merge
dynass <- data.table(dynass)
setkey(dynass,pdpass,year)
setkey(inventorsPatents,pdpass,year)
# Merge
inventorsPatentsDynass <- merge(inventorsPatents,dynass)
## Clean up: remove inventorsAndPatents and dynass
rm(list = c("inventorsPatents","dynass"))
#### Merge patentsAssigneesDynass with compustat's XRD data
## Load compustat dataset and clean
compustat <- fread('Data/compustat.csv')
compustat <- compustat %>% select(gvkey,fyear,xrd,state)
compustat$year <- compustat$fyear
compustat$gvkey <- as.integer(compustat$gvkey)
## Merge and clean
# Convert compustat to data.table and set keys
setkey(compustat,gvkey,year)
setkey(inventorsPatentsDynass,gvkey,year)
inventorsPatentsCompustat <- merge(inventorsPatentsDynass,compustat,by = c("gvkey","year"),all.y = TRUE)
# For diagnostics, save here so I don't have to redo above
inventorsPatentsCompustat <- inventorsPatentsCompustat %>% select(-pdpass,-fyear)
#fwrite(inventorsPatentsCompustat, file = "Data/inventorsPatentsCompustat.csv")
#inventorsPatentsCompustat <- fread("Data/inventorsPatentsCompustat.csv", na.strings = c("",NA))
# Count number of patents per gvkey-year to modify weight so we can simply sum over gvkey-year entries later
inventorsPatentsCompustat[, numInventorsInGvkeyYearPatent := .N, by = c("gvkey","year","patent")]
inventorsPatentsCompustat[, numPatentsInGvkeyYear := uniqueN(patent), by = c("gvkey","year")]
inventorsPatentsCompustatWeights <- inventorsPatentsCompustat[, weight := 1 / (numInventorsInGvkeyYearPatent * numPatentsInGvkeyYear)]
rm(list = c("inventorsPatentsCompustat","compustat"))
# Make tibble - necessary for spread()
inventorsPatentsCompustatWeights[is.na(inventorState),inventorState := state]
inventorsPatentsCompustatWeights[,state := NULL]
inventorsPatentsCompustatWeights <- inventorsPatentsCompustatWeights %>% dplyr::rename(state = inventorState)
# Compute sum of weights by gvkey-year-inventorState
gvkeyYearStateWeights <- inventorsPatentsCompustatWeights[, lapply(.SD,sum), by = c("gvkey","year","state"), .SDcols = "weight"]
gvkeyYearXrd <- unique(inventorsPatentsCompustatWeights, by=c("gvkey","year"))[,c("gvkey","year","xrd")]
# Compute moving averages
# First sort by gvkey-year
setkey(gvkeyYearStateWeights,gvkey,year)
# Reshape to wide
gvkeyYearStateWeights[, ID := .I]
gvkeyYearStateWeights <- gvkeyYearStateWeights %>% spread(state,weight)
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[, names(gvkeyYearStateWeights) := lapply(.SD, function(x) {x[is.na(x)] <- "0"; x})]
gvkeyYearStateWeights[,.SD := as.numeric(.SD), .SDcols = 3:68]
gvkeyYearStateWeights[,.SD := as.numeric(as.character(.SD)), .SDcols = 3:68]
gvkeyYearStateWeights[,.SD[3:68] := as.numeric(as.character(.SD)), .SDcols = 3:68]
gvkeyYearStateWeights[,3:68 := as.numeric(as.character(.SD)), .SDcols = 3:68]
gvkeyYearStateWeights[,lapply(.SD,as.numeric(as.character())), .SDcols = 3:68]
# Compute sum of weights by gvkey-year-inventorState
gvkeyYearStateWeights <- inventorsPatentsCompustatWeights[, lapply(.SD,sum), by = c("gvkey","year","state"), .SDcols = "weight"]
# Compute moving averages
# First sort by gvkey-year
setkey(gvkeyYearStateWeights,gvkey,year)
# Reshape to wide
gvkeyYearStateWeights[, ID := .I]
gvkeyYearStateWeights <- gvkeyYearStateWeights %>% spread(state,weight)
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[, names(gvkeyYearStateWeights) := lapply(.SD, function(x) {x[is.na(x)] <- "0"; x})]
# Compute sum of weights by gvkey-year-inventorState
gvkeyYearStateWeights <- inventorsPatentsCompustatWeights[, lapply(.SD,sum), by = c("gvkey","year","state"), .SDcols = "weight"]
# Compute moving averages
# First sort by gvkey-year
setkey(gvkeyYearStateWeights,gvkey,year)
# Reshape to wide
gvkeyYearStateWeights[, ID := .I]
gvkeyYearStateWeights <- gvkeyYearStateWeights %>% spread(state,weight)
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[, names(gvkeyYearStateWeights) := lapply(.SD, function(x) {x[is.na(x)] <- 0; x})]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = numeric(0)), .SDcols = 3:68]
View(new_weights)
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = numeric(0)), by = gvkey, .SDcols = 3:68]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = numeric(0)), by = "gvkey", .SDcols = 3:68]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = numeric(0)), .SDcols = 3:68, by = gvkey]
?roll_mean
rm(new_weights)
rm(list = c("gvkeyYearXrd","gvkeyYearStateWeight"))
rm(list = c("gvkeyYearXrd","gvkeyYearStateWeights"))
# Compute sum of weights by gvkey-year-inventorState
gvkeyYearStateWeights <- inventorsPatentsCompustatWeights[, lapply(.SD,sum), by = c("gvkey","year","state"), .SDcols = "weight"]
gvkeyYearXrd <- unique(inventorsPatentsCompustatWeights, by=c("gvkey","year"))[,c("gvkey","year","xrd")]
rm(list = c("inventorsPatentsCompustatWeights"))
# Compute moving averages
# First sort by gvkey-year
setkey(gvkeyYearStateWeights,gvkey,year)
# Reshape to wide
gvkeyYearStateWeights[, ID := .I]
gvkeyYearStateWeights <- gvkeyYearStateWeights %>% spread(state,weight)
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[, names(gvkeyYearStateWeights) := lapply(.SD, function(x) {x[is.na(x)] <- 0; x})]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = numeric(0)), .SDcols = 3:68]
rm(new_weights)
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = numeric(0)), .SDcols = 3:68, by = gvkey]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = numeric(0)), .SDcols = 3:68, by = "gvkey"]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
View(new_weights)
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,rollapply,width = 2,align = 'right', fill = NA), .SDcols = 3:68, by = "gvkey"]
library(zoo)
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,rollapply,width = 2,align = 'right', fill = NA), .SDcols = 3:68, by = "gvkey"]
rm(new_weights)
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68, by = "gvkey")]
View(new_weights)
View(gvkeyYearStateWeights)
rm(new_weights)
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68, by = "gvkey"), .SDcols = .(gvkey,year)]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
new_weights <- gvkeyYearStateWeights[, lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68, by = "gvkey"), .SDcols = 3:68]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
new_weights <- gvkeyYearStateWeights[, .SD[,3:68]:=lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68, by = "gvkey"), .SDcols = 3:68]
gvkeyYearStateWeightsCopy = copy(gvkeyYearStateWeights)
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, 3:68 := lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68, by = "gvkey"), .SDcols = 3:68]
View(gvkeyYearStateWeights)
View(gvkeyYearStateWeightsCopy)
?rollmean
gvkeyYearStateWeights <- gvkeyYearStateWeightsCopy
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, 3:68 := lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68), by = "gvkey",.SDcols = 3:68]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, 3:68 := lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68, by = "gvkey"), by = "gvkey",.SDcols = 3:68]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, 3:68 := lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68), by = (gvkey),.SDcols = 3:68]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, 3:68 := lapply(.SD,rollmean,k=3,fill = NA,align = "right", .SDcols = 3:68),by = gvkey, .SDcols = 3:68]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, 3:68 := lapply(.SD,rollmean,k=3,fill = NA,align = "right"),by = gvkey, .SDcols = 3:68]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, 3:68 := lapply(.SD,rollmean,k=3,fill = NA,align = "right"),.SDcols = 3:68, by = gvkey]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, AB := lapply(.SD,rollmean,k=3,fill = NA,align = "right"),.SDcols = AB, by = gvkey]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, "AB" := lapply(.SD,rollmean,k=3,fill = NA,align = "right"),.SDcols = "AB", by = gvkey]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, "AB" := lapply(.SD,zoo::rollmean,k=3,fill = NA,align = "right"),.SDcols = "AB", by = gvkey]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
gvkeyYearStateWeights[, "AB_ma3" := lapply(.SD,zoo::rollmean,k=3,fill = NA,align = "right"),.SDcols = "AB", by = gvkey]
set.seed(1234)
data.frame(Week = rep(seq(1:5), 3),
Section = c(rep("a", 5), rep("b", 5), rep("c", 5)),
Qty = runif(15, min = 100, max = 500),
To =  runif(15, min = 40, max = 80))
rm(list = ls())
set.seed(1234)
data.frame(Week = rep(seq(1:5), 3),
Section = c(rep("a", 5), rep("b", 5), rep("c", 5)),
Qty = runif(15, min = 100, max = 500),
To =  runif(15, min = 40, max = 80))
set.seed(1234)
df <- data.frame(Week = rep(seq(1:5), 3),
Section = c(rep("a", 5), rep("b", 5), rep("c", 5)),
Qty = runif(15, min = 100, max = 500),
To =  runif(15, min = 40, max = 80))
df
setDT(df)[, c("Qty.mean","To.mean") := lapply(.SD, rollmean, k = 3, fill = NA, align = "right"),
.SDcols = c("Qty","To"), by = Section]
rm(list = setdiff(ls(), lsf.str()))
setwd("/home/nico/nfernand@princeton.edu/PhD - Big boy/Research/Endogenous growth with worker flows and noncompetes/data/work")
## Load libraries and auxiliary functions
library(profvis)
library(readstata13)
library(dplyr)
library(plyr)
library(tidyr)
library(data.table)
library(plm)
source('Code/Functions/stata_merge.R')
##### Load in and clean patents dataset
patents <- fread('Data/patents.csv')
patents <- patents %>% dplyr::rename(year = appyear, assigneeState = state, assigneeCountry = country)
patents <- patents %>% dplyr::select(patent,pdpass,year)
##### Load in and clean inventors datasets
# Use data.table::fread -- it is an order of magntiude faster than read.csv
inventors <- fread(file = "Raw/inventor.csv")
# Rename variables
inventors <- inventors %>% dplyr::rename(patent = Patent, inventorCountry = Country, inventorZipCode = Zipcode, inventorState = State, inventorCity = City)
# Convert patent # to numeric. Non-utility patents have non-numeric characters, so these become NAs
# and can then be dropped.
inventors[, patent := as.numeric(as.character(patent))]
#inventors$patent <- as.numeric(as.character(inventors$patent))
inventors[, inventorState := as.character(inventorState)]
#inventors$inventorState <- as.character(inventors$inventorState)
inventors <- inventors[!is.na(patent)]
#inventors <- inventors %>% dplyr::filter(!is.na(patent))
# Select only relevant variables: patent number and inventor state
inventors <- inventors %>% dplyr::select(patent,inventorState)
##### Merge datasets using data.table
setkey(inventors,patent)
setkey(patents,patent)
inventorsPatents <- merge(patents,inventors)
##### Clean up: remove inventors, patents data.tables
rm(list = c("inventors","patents"))
######################################################################
######################################################################
## Construction of geographic distribution of R&D for each gvkey-year
#
## Algorithm:
#
# For inventorsPatents dataset, Create new variable, inventorCount, that
# counts number of inventors for each patent (i.e. count # of observations per patent)
# Then invert - this is now the weight assigned to each patent-city observation.
#
# This only gives me the ability to assign a state to gvkey-year observations
# that match the patent database, i.e. where the company applied for
# a patent.
#
# In order to use all, need to next import dynass and compustat,
# merge with inventorsPatentsWeights, and do the following:
#
# (1) Assign a weight of 1 to gvkey-year observations which do not have a patent
# (2) Assign the gvkey-year state to inventorState for those observations
# (i.e. treat all R&D as occuring in the main state of the company when the company
# does not apply for any patents in that year - the natural approximation)
#
######################################################################
######################################################################
### Compute weights - easy with data.table
#inventorsPatentsWeights <- inventorsPatents[ , weight := .N, by]
#inventorsPatentsWeights$weight <- 1/inventorsPatentsWeights$weight
# clean up
#rm(list=c("inventorsPatents"))
### Load in dynass, compustat and merge
## Load dynass
dynass <- read.dta13('Data/dynass_reshaped.dta')
# Clean
dynass$gvkey <- as.integer(dynass$gvkey)
dynass <- dynass %>% select(gvkey,pdpass,year)
## Merge inventorsPatentsWeights and dynass
# Prepare for merge
dynass <- data.table(dynass)
setkey(dynass,pdpass,year)
setkey(inventorsPatents,pdpass,year)
# Merge
inventorsPatentsDynass <- merge(inventorsPatents,dynass)
## Clean up: remove inventorsAndPatents and dynass
rm(list = c("inventorsPatents","dynass"))
#### Merge patentsAssigneesDynass with compustat's XRD data
## Load compustat dataset and clean
compustat <- fread('Data/compustat.csv')
compustat <- compustat %>% select(gvkey,fyear,xrd,state)
compustat$year <- compustat$fyear
compustat$gvkey <- as.integer(compustat$gvkey)
## Merge and clean
# Convert compustat to data.table and set keys
setkey(compustat,gvkey,year)
setkey(inventorsPatentsDynass,gvkey,year)
inventorsPatentsCompustat <- merge(inventorsPatentsDynass,compustat,by = c("gvkey","year"),all.y = TRUE)
# For diagnostics, save here so I don't have to redo above
inventorsPatentsCompustat <- inventorsPatentsCompustat %>% select(-pdpass,-fyear)
#fwrite(inventorsPatentsCompustat, file = "Data/inventorsPatentsCompustat.csv")
#inventorsPatentsCompustat <- fread("Data/inventorsPatentsCompustat.csv", na.strings = c("",NA))
# Count number of patents per gvkey-year to modify weight so we can simply sum over gvkey-year entries later
inventorsPatentsCompustat[, numInventorsInGvkeyYearPatent := .N, by = c("gvkey","year","patent")]
inventorsPatentsCompustat[, numPatentsInGvkeyYear := uniqueN(patent), by = c("gvkey","year")]
inventorsPatentsCompustatWeights <- inventorsPatentsCompustat[, weight := 1 / (numInventorsInGvkeyYearPatent * numPatentsInGvkeyYear)]
rm(list = c("inventorsPatentsCompustat","compustat"))
# Make tibble - necessary for spread()
inventorsPatentsCompustatWeights[is.na(inventorState),inventorState := state]
inventorsPatentsCompustatWeights[,state := NULL]
inventorsPatentsCompustatWeights <- inventorsPatentsCompustatWeights %>% dplyr::rename(state = inventorState)
# Compute sum of weights by gvkey-year-inventorState
gvkeyYearStateWeights <- inventorsPatentsCompustatWeights[, lapply(.SD,sum), by = c("gvkey","year","state"), .SDcols = "weight"]
gvkeyYearXrd <- unique(inventorsPatentsCompustatWeights, by=c("gvkey","year"))[,c("gvkey","year","xrd")]
# Compute moving averages
# First sort by gvkey-year
setkey(gvkeyYearStateWeights,gvkey,year)
# Reshape to wide
gvkeyYearStateWeights[, ID := .I]
gvkeyYearStateWeights <- gvkeyYearStateWeights %>% spread(state,weight)
# Now can compute rolling averages of weights for each state easily
gvkeyYearStateWeights[, names(gvkeyYearStateWeights) := lapply(.SD, function(x) {x[is.na(x)] <- 0; x})]
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
setDT(gvkeyYearStateWeights)[, "AB_ma3" := lapply(.SD,zoo::rollmean,k=3,fill = NA,align = "right"),.SDcols = "AB", by = gvkey]
gvkeyYearStateWeights
View(gvkeyYearStateWeights)
#new_weights <- gvkeyYearStateWeights[, lapply(.SD,RcppRoll::roll_mean,n = 3L,fill = NA), .SDcols = 3:68, by = "gvkey"]
setDT(gvkeyYearStateWeights)[, c("AB_ma3") := lapply(.SD,zoo::rollmean,k=3,fill = NA,align = "right"),.SDcols = c("AB"), by = gvkey]
View(gvkeyYearStateWeights)
library(tidyquant)
install.packages("tidyquant")
library(tidyquant)
install.packages("tidyverse")
install.packages("rvest")
install.packages("xml2")
